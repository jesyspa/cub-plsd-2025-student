# Software Development: Current Overview, Future Trends, and Language Improvements

The field of software development has always been a rapidly advancing area, but with every major change the rate at which subsequent major changes appear grows. It would not be incorrect to point out how swiftly Artificial Intelligence has appeared, made its way into our process of writing software (and other processes) and forced us to rethink how we work with our programming tools, languages, and how we collaborate.

---

## Q1: What major changes have there been in software development in the last 3–5 years, and how do they impact the work of a software engineer?

The biggest event of the last 3-5 years is undoubtedly the inception of Artificial Intelligence models such as large language models (LLMs). 

This inception led to many ramifications, like the increase of output in terms of volume, (such as the number of images generated by AI)[1]. Another factor here refers to the increased focus on turning such tech "green" given its high emissions, hardware turnover, and marginal training gains compared to overwhelming energy cost[2] [3].

Directly related to the apparition of AI and LLMs, the creation of "Vibe Coding", a chatbot-based approach to developing software, where a user discusses an idea with an LLM, which then generates an output. These platforms offer an opportunity to everyone from seasoned developers to complete laymen, democratizing the process.

Moving away from AI, the sheer number of people writing code has greatly increased as each year concluded[4] [5].

Another major trend refers to the increased usage of cloud computing. Businesses and other services now rely more on tech such as AWS, Google Cloud and MS Azure. For example, this increased dependence resulted in AWS achieving an annualized revenue run rate of more than $123 billion[6].

The changes described above pave the way forward for other alterations that are yet to come.

---

## Q2: What further changes do you expect to see in the coming 3–5 years?

As it stands, I find it difficult to find another technology comparable to AI in terms of far-reaching consequences and output, and therefore it is my speculation that the hegemony AI displays over the industry and the world at large will continue to exert itself. Given the interest in making the tech more eco friendly, I also believe it will become less costly to train, operate, and get access to, leading to more usage.

The role of software developers will continue to shift from "person writing a piece of code" to "overseer of AI-written code". The trend of importance placed more on verifying code rather than writing it will grow, along with the increased need of great communication skills for better AI prompting and corporate communications.

The fact that cloud computing platforms are mostly controlled by a few monumental companies could give way to a sinister domino effect that may result in a large amount of infrastructure being broken / lost. An example of this is listed in this article from Investopedia[7], where they discuss why such an oligopoly is capable of resulting in great problems.

These possible changes force us to think harder about the improvements we can make to our programming languages, so that we can "future proof" them.

---

## Q3: What can be improved about programming languages and their tooling to better fit these changes?

The factors I believe to be most relevant for the improvement of programming languages and their tooling are:

- **Speed**. It is the most important aspect of the software development process, and as such, compiled performance is very important.

- **Strict error checking**. When it comes to ML / LLM training, not wasting resources is of key importance. Discovering a problem with our setup deep in the training process would waste considerable time and resources. Strict compiler-style checks would help mitigate such problems, as they would verify everything before we begin execution.

- **Ease of use**. The appeal of languages like Python is their quick writing, prototyping and simple syntax, so having the same ease of use, easy to understand syntax and strict checking would bring a good balance.

- **Ways to guarantee determinism**. A lot of problems in ML come from mismatching dependencies and not being able to reproduce experiments. Configuration that has "standardized" environments, package versions and seeds for experiments baked into the language should help mitigate such problems.

The examples above must be estimated in some way in order to gauge their effectiveness and how well they fit into the modern flow of development.


---

## Q4: How can we measure whether a language is a good fit for the modern development flow?

We can think of the "modern development flow" as the process of developing an application, and refer to three main phases: Design, Implementation, and Testing. In this vein, there are many methodologies that are currently in use, such as Agile Development, which can be said to embody the characteristics of a modern development flow. 

To measure the fit of a language into the modern flow, we must consider what this flow is like.

First, developers must move quickly from the initial design phase and through implementation, so that they may receive feedback, and scrap / change / add different parts to what already exists. Therefore, **speed** is one way we can measure this fit.

Second, a developer cannot easily create an enterprise-ready application without cooperation, and therefore a language that integrates well with tools which allow for team **collaboration** (JetBrains Code With Me), version control (Git) and code reviews (GitHub) are a better fit. Checking the availability of these features is the measurement in this case.

Third, **verification** is another important aspect of the modern flow, and languages where one can easily test the code they wrote, along with strict error checking are a better fit. The proportion of compile-time caught errors and the quality of available testing frameworks are the measurements for this point.

Lastly, the process itself has many facets to keep track of, and can get very complex for the average developer. In order to make their life easier, the language should be **easy to use** and provide good tooling, like build tools, easy to understand syntax, and clear documentation. The main way to measure these benchmarks would be developer surveys.


---

## Conclusion

We have discussed some of the biggest changes of the domain to date, speculated on what future changes might look like, and what to improve to make sure we continue to keep up with these changes. Finally, we mentioned ways in which we can measure our improvements, to make sure they actually have the intended outcome. In a way, the document represents a possible blueprint for how software development may evolve from this point in time forward.

---

## Sources

1. [AI Image Statistics – Everypixel Journal](https://journal.everypixel.com/ai-image-statistics)  
2. [Arxiv: Energy and Policy Considerations for Deep Learning](https://arxiv.org/abs/2507.09611)  
3. [Arxiv: Green AI Efficiency Research](https://arxiv.org/abs/2412.09731)  
4. [JetBrains Developer Ecosystem Data](https://www.jetbrains.com/lp/devecosystem-data-playground/)  
5. [Statista – Worldwide Developer Population](https://www.statista.com/statistics/627312/worldwide-developer-population/)  
6. [Datacenter Dynamics – AWS Revenue Report](https://www.datacenterdynamics.com/en/news/aws-achieves-123bn-annualized-revenue-run-rate-capex-for-the-year-set-to-exceed-118bn/)  
7. [Investopedia – Cloud Computing Risk for the Economy](https://www.investopedia.com/cloud-computing-risk-for-the-economy-11777456)  