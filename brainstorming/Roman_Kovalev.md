## Exercise 1 (2 pts)
In the last 3-5 years, software development has been strongly impacted by the rise of cloud computing, artificial intelligence, and DevOps practices. Cloud services like AWS and Azure have made it easier to deploy and scale applications. AI tools, including code assistants, have sped up the development process. Already, there are products like Junie and Cursor that allow developers to start building products not completely from scratch but from a kind of "prototype," even if it is not fully working. A new concept called "vibecoding" has appeared — a process that saves time when writing code but slightly increases the chance of mistakes. Therefore, code generation is very useful for simpler tasks, but for more complex systems, it is better to write code manually to avoid "hallucinations" of generative models.


## Exercise 2 (2 pts)
In the next 3-5 years, we can expect even deeper integration of AI in software development. Tools for automated code generation and testing will become more advanced, reducing manual work. Low-code and no-code platforms will grow, making development accessible to non-programmers. Cybersecurity will become even more important as software systems grow in complexity. Cloud-native development will dominate, with a focus on containerization and microservices. Engineers will need to adapt by learning about AI-driven workflows and security-first design.


## Exercise 3 (3 pts)
Programming languages need better built-in support for concurrency and parallelism to match modern multi-core systems. Tooling should include stronger automated code analysis to catch bugs and security issues earlier. Languages can also improve developer experience by offering simpler syntax and better error messages. Integration with AI-driven assistants should be built into IDEs and compilers. Open-source communities could focus on creating standard libraries for cloud and machine learning tasks. These changes would make languages more aligned with today’s development practices.


## Exercise 4 (3 pts)
To measure if a language fits the modern development flow, we can check these factors:


- **Productivity/Understandability** – how quickly developers can deliver features and fix bugs.  
- **Performance** – runtime speed and efficient resource usage.  
- **Ecosystem support** – availability of libraries, frameworks, maybe active community.  
- **Security** – built-in safety features and ease of debugging, without dangerouse for system.  
- **Integration** – how well the language works with CI/CD, cloud platforms, and modern tools.  


## Exercise 5 (2 pts)
- [Modernizing DevOps with AI, Boosting Productivity, and Redefining Developer Experience (InfoQ Live)](https://www.infoq.com/presentations/generative-ai-2025/)  
- [From DevOps to 'Vibe Coding': Gene Kim on AI-Assisted Development and Platform Engineering (Platform Engineering Podcast)](https://www.platformengineeringpod.com/episode/from-devops-to-vibe-coding-gene-kim-on-ai-assisted-development-and-platform-engineering)  
- [Advancing DevOps: Infrastructure as Code, Platform Engineering & Gen AI (Futurum Group)](https://futurumgroup.com/insights/advancing-devops-infrastructure-as-code-platform-engineering-and-gen-ai-six-five-webcast/)  


## Exercise 6 (2 pts)
Over the past few years, software engineering has changed quickly, with cloud computing, AI, and DevOps reshaping how developers work. Looking ahead, the role of AI and automation will grow, while security and scalability will become even more important. To adapt to these changes, programming languages must evolve with better tooling, simpler design, and stronger integrations. By measuring productivity, performance, and ecosystem health, we can find languages that fit modern workflows.
